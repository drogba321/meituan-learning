##20150810-20150823（入职第五、六周）##


###MySQL索引###

- 索引用来快速找出在某个列中有一特定值的行。如果没有索引，就需要顺序地从表的第一行逐行扫描所有的数据，从而找到目标数据，而有了索引后，就可以快速找到目标数据了。
- 常见的索引数据结构是**B+树**，通过从树的根节点层层向下，逐渐地缩小查找的范围，直到在叶子节点上找到目标数据。对于有N个数据的表来说，如果不建立索引，需要花费O(N)时间；如果建立索引（采用M叉的B+树），则只需要花费logM(N)时间，性能显著提升。
- 一般来说，不必对所有列都建立索引，一般对在查询条件中经常出现的**等值**查询字段建立索引。例如在MySQL的where子句中经常出现“userid=****”的查询条件，则就需要对userid列建立索引。
- 一般应当对区分度较大的字段建立索引，例如userid、username等等。这样在索引树中每向下查找一层，查找范围就会缩小很多，很快就能找到目标数据。而对区分度较小的字段（例如性别字段）不需要建立索引，因为在索引树中每向下查找一层，查找范围缩小的并不多，仍需要从很多数据中才能找到目标数据。
- 索引的建立需要额外的磁盘空间开销，并且在写操作时有额外的建索引开销，因此不经常使用的索引就没必要建立了，得不偿失。
- 索引具备**最左前缀匹配原则**，例如对多个字段name、age、job建立索引（注意这些字段是有顺序的），会首先匹配name字段，找到所有name相匹配的行，再匹配下一个字段age，找到所有age相匹配的行，以此类推，直到遇到范围查询就停止匹配。若查询条件中某个字段缺失，则会把全部行都查询出来，再匹配下一个字段。

###hbase设计经验###

- 行键（rowkey）的选择，首先不要选择以时间戳作为rowkey前缀，因为hbase会根据rowkey将新写入的数据分配到集群的某个节点上，若使用时间戳作为rowkey前缀，则相邻写入的数据的rowkey也是相邻的（未散列过的），所以它们会被分配到同一个节点上，造成写入的负载严重不均衡，因此rowkey要选择**经过良好散列的值**，使得数据能够尽量平均地分配到各个节点上。
- 另外，rowkey应当选用**经常进行等值查询的列值**，例如在userid列上经常进行等值查询，则可以使用userid值作为rowkey的前缀，这样在执行userid等值查询的时候可以直接通过rowkey来查，而不必使用过滤器或二级索引等其他方式，通过rowkey查询的效率是最快的。注意：用作rowkey前缀的列一定要能良好的散列开。
- hbase的过滤器机制：hbase会将所有读取出来的数据逐个通过过滤器，满足过滤器条件的数据放行，不满足条件的则舍弃，最终生成过滤器的结果集。

###其他杂记###

- linux下的crontab命令示例：`00 20 * * * <do something>`，该命令表示每天晚上20:00执行某个事情。该命令放在/var/spool/cron目录下、以当前用户名命名的文件中。
- linux 替换文本文件的内容，举例：`grep -rl 9090 dev-conf/conf.properties | xargs sed -i 's/9090/9091/g'`。其执行逻辑是：先通过grep命令在dev-conf/conf.properties这个路径下找到匹配字符串“9090”的部分，然后通过sed命令将其中的“9090”替换为“9091”。
- 在java中报错“NoSuchMethodError”往往是因为jar包版本不对，新旧版本中的方法定义不同而导致的。
- ruby on rails的很多语法糖，简便好用，此处略。



